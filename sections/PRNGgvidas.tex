\section{PRNG (Find en god titel til kapitlet)}
Før der introduceres til pseudotilfældige tal og genereringen af disse, er det vigtigt at vide og forstå, hvad tilfældige tal egentlig er, og hvilke anvendelsesmuligheder de har. Når der tænkes på tilfældige tal, er det svært at argumentere for, om et bestemt tal er tilfældigt eller ej. For eksempel giver det ikke mening at overveje, om tallet 9 er tilfældigt. Derimod giver det god mening at tænke på en sekvens af tal, hvor tallene i sekvensen er valgt tilfældigt. At blive valgt tilfældigt betyder, at hvert tal vælges uafhængigt af alle de andre tal i sekvensen, og at sandsynligheden for at vælge et tal er ens for alle de mulige tal. Tallene følger altså en uniform fordeling \textbf{(reference til kapitlet om uniformfordelingen)}, hvis der tages udgangspunkt i cifrene 0 til 9, betyder det at hvert cifre vil blive valgt $\frac{1}{10}$ af tiden. Anvendelsen af tilfældige tal er vidtrækkende og rækker over flere forskellige brancher. I sin bog “The Art of Computer Programming” 
\cite{Knuth1998}
giver professor Donald E. Knuth fra Stanford University eksempler på nogle af de mange anvendelser af tilfældige tal, der understreger deres vigtighed. Disse inkluderer tekniske anvendelser som anvendelse af tal til computersimulering af virkelige naturfænomener, men også helt anderledes anvendelser som anvendelser til æstetiske formål, hvor lidt tilfældighed eksempelvis er med til at gøre computer-genererede grafikker mere livlige.

\subsection{Genereringen af tilfældige tal}
Genereringen af tilfældige tal foregik for mange år siden manuelt, hvor man trak kort, rullede terninger, kastede en mønt eller lignende. Som følge af computerens udbredelse begyndte man at finde på metoder, der kunne generere tilfældige tal automatisk ved brug af computerprogrammer. Nogle af disse metoder vil blive gennemgået i de kommende kapitler.
Computere er deterministiske, hvilket betyder, at alle resultater og handlinger udføres på en systematisk måde. Computerens resultater kan forudsiges med sikkerhed, hvis der blot er kendskab til den algoritme som computeren udfører, og den initierede inputværdi. Dette giver anledning til undring over, hvordan en computer kan generere tilfældige tal, når dens handlinger og resultater kan forudsiges. Her kommer ordet "pseudo" ind i billedet. Computere kan nemlig aldrig generere helt tilfældige tal, men de kan producere sekvenser af tal, der ser ud til at være tilfældige. Disse tal kaldes pseudotilfældige tal, og programmer, der genererer dem, er bedst kendt som "pseudo random number generators" eller forkortet PRNG. For at vurdere, hvor god en PRNG er, kigger man på længden af den sekvens, som PRNG er i stand til at generere, før tallene begynder at gentage sig. Længden af denne sekvens kaldes et cyklus, og jo længere cyklus, desto bedre er PRNG'en. Selvom alle PRNG'er har en cyklus, hvor de genererede tal gentager sig, er cykluslængden af de gode PRNG'er tilstrækkelig til at løse de fleste opgaver. I de følgende kapitler undersøges eksempler og sammenligninger af cykluslængder af konkrete PRNG'er. Inden der fortsættes til konkrete eksempler på PRNG'er, er det værd at nævne et fænomen inden for generering af tilfældige tal, som er i stand til at generere sande tilfældige tal. Det vil sige, at den genererede sekvens af tilfældige tal er en ikke-deterministisk sekvens, der ikke gentager sig. Disse generatorer kaldes for true random number generators, forkortet TRNG, og de genererer tal ud fra fysiske processer som elektronisk støj, atmosfærisk støj eller radioaktivt henfald. En videnskabelig artikel fra Japan udgivet i 2021
\cite{Matsuoka2021} 
giver bud på fire måder, hvorpå en TRNG kan udarbejdes ved hjælp af termisk støj. Da arbejdet med TRNG'er er ressourcekrævende og ligger uden for projektets omfang, ses der bort fra TRNG'er til generering af tilfældige tal i dette projekt.

\subsection{Middle-square}
"Middle-square" metoden, opfundet af John Von Neumann, er en algoritme til at generere pseudotilfældige tal. Algoritmen fungerer ved at tage et to- eller firecifret tal (kendt som "seed"), som er det første tal, $x_0$, i den nye sekvens. Dernæst kvadreres $x_0$, hvilket resulterer i et otte- eller syvcifret tal. Hvis tallet er syvcifret, tilføjes en nul foran. De fire midterste cifre i det kvadrerede tal bruges som det næste "seed". Algoritmen forventes at producere en tilfældig sekvens uden et klart mønster.
\noindent Metoden "middle-square" er langt fra perfekt, da der er forskellige tal, som kan føre til gentagne tal, såsom $0000$, $0100$, $2500$, $3792$ og $7600$. Derudover vil algoritmen på et tidspunkt løbe ind i en af $13$ cyklusser. Den mest almindelige cyklus er $4100$, $8100$, $6100$ og $2100$, og det længste talrække, som metoden kan producere, er 142 \cite{Knuth1998}.
\noindent Fordelen ved "middle-square" metoden er dens relative enkelhed i implementeringen og talgenerering, dog kan den ikke producere en lang talrække. En anden stor ulempe ved "middle-square" metoden er, at den kan sætte sig fast og vil altid falde i en cyklus, der producerer de samme tal igen og igen. Derfor er "middle-square" ikke en god pseudotilfældig talgenerator.


\subsection{Lagged Fibonacci}
Metoden "Lagged Fibonacci" er en teknik til at generere pseudotilfældige tal, som ligner tilfældige tal. Den er baseret på Fibonacci-sekvensen, hvor hvert tal $S_n$ er summen af de to foregående tal, $S_{n-1}$ og $S_{n-2}$, og er matematisk udtrykt som:

$$S_n=S_{n-1}+S_{n-2}$$

\noindent Hvis Fibonacci-sekvensen starter med $0$, vil de første ti tal i rækken være: $0,1,1,2,3,5,8,13,21,34,55...$. Introduktionen af "Lagged Fibonacci" skyldes, at Fibonacci-sekvensen har et tydeligt mønster. "Lagged Fibonacci"-metoden kan beskrives ved udtrykket:

$$x_i \equiv (x_{i-j} \oplus x_{i-k}) \mod m, \quad \text{hvor} \quad 0<j<k<i$$

\noindent Her betegner operatoren $\oplus$ division, gange, minus eller plus. Hvis $j$, $k$ og $m$ er valgt korrekt, kan metoden producere en lang talrække, som ser tilfældig ud \cite{RNGMonteCarlo}.
\noindent Et eksempel på anvendelsen af Lagged Fibonacci kunne være, hvis $j = 3$, $k = 7$, $m = 11$, og et seed value $= 2459259$. I første skridt er $j=5$ og $k=9$, som bliver $5+9$ (mod 11), som giver $3$. Parameterne $j$ og $k$ bestemmer, hvilket tal i seedvaluen, der skal bruges til at udregne det næste Fibonacci-tal.
\noindent I "The Art of Computer Programming" \cite{Knuth1998} har Knuth opstillet en tabel med de bedste værdier for $j$ og $k$ når $m = 2$. Disse kan ses i tabellen nedenfor. Periodelængden, som er den tid det tager, før generatoren begynder at producere en gentagelse af dens sekvens af tal, afhænger af k-værdien og antallet af bits (e). Udregning af antallet bits består af $2^{e-1}>m$. Udregning af længden kan beskrives som:
$$L = 2^{e-1}(2^k - 1)$$

\noindent Fordelen ved "Lagged Fibonacci" metoden er dens enkelhed i implementeringen og talgenerering, og talrækken vil se tilfældig ud. Ulempen er selvfølgelig, at "Lagged Fibonacci" er en pseudotilfældig talgenerator, så derfor vil tallene ikke være helt tilfældige.
\begin{table}[h]
    \centering
    \caption{Bedste $j$ og $k$ værdier når $modulo$ er $2$}
    \begin{tabular}{|c|c|}
    \hline
    (j, k) \\
    \hline
    (24,55) \\
    (37,100) \\
    (83,258) \\
    (273,607) \\
    (576,3217) \\
    (107,378) \\
    (1029,2281) \\
    (4187,9689) \\
    (9739,23209) \\
    \hline
    \end{tabular}
    \end{table}



\subsection{Linear Congruential Generator}
Den mest populære PRNG er Linear Congruential Generator (LCG). Denne PRNG er rekursiv og kan beskrives vha. denne formel:\\\\
\(X_{n+1}=(aX_{n}+c)\, \textup{mod}\, m\\\)
Hvor de forskellige variable kan beskrives således:\\\\
\(X_{0},\; \; \textup{Startv\ae rdi (Seed)}; \: \: \: 0 \leq X_{0}< m\\a,\: \: \textup{Multiplikator};\: \:\:  0\leq a< m\\c,\: \: \textup{Konstant};\: \: \: 0\leq c< m\\m,\: \: \textup{Restdivident\,(mod er operatoren for restdivisionen)};\: \: \: 0< m\\\)
Et eksempel på en LCG sekvens kunne se således ud:\\\\
\(X_{0}=1\\a=3\\c=2\\m=5\\\\X_{1}=(3*1+2)\, \textup{mod}\, 5=0\\X_{2}=(3*0+2)\, \textup{mod}\, 5=2\\X_{3}=(3*2+2)\, \textup{mod}\, 5=3\\X_{4}=(3*3+2)\, \textup{mod}\, 5=1\\X_{5}=(3*1+2)\, \textup{mod}\, 5=0\)\\
\\\\Det kan ses at denne sekvens har en cyklus på 4 tal. LCG's cyklus har en maksimal længde på \textit{m}. Det er derfor fordelagtigt at vælge et tal \textit{m} som er stort. Dog er dette ikke den eneste faktor man burde tage i betragtning når man vælger et tal \textit{m}. I et eksempel på en LCG sekvens er det muligt at se hvorfor et højt tal \textit{m} ikke altid er fordelagtigt:\\\\\(X_{0}=1\\a=3\\c=2\\m=24\\\\X_{1}=(3*1+2)\, \textup{mod}\, 24=5\\X_{2}=(3*5+2))\, \textup{mod}\, 24=17\\X_{3}=(3*17+2))\, \textup{mod}\, 24=5\)
\\Det ses at denne sekvens kun har en længde på 2 tal. For at få en lang cyklus ved brug af LCG er det derfor vigtigt hvilke variable der vælges. Dette emne er blevet forsket i af matematikere og dataloger, da det indeholder en del tal teori\cite{Sigman}. 